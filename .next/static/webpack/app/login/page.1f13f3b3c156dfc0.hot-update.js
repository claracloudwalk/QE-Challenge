"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api)\n/* harmony export */ });\nconst API_BASE_URL = 'https://qe-api.services.staging.cloudwalk.network';\nconst api = {\n    async getBalance (userId) {\n        console.log('API: Buscando saldo para userId:', userId);\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(userId), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                console.error('API: Erro ao buscar saldo:', response.status, response.statusText);\n                throw new Error('Failed to fetch balance');\n            }\n            const data = await response.json();\n            console.log('API: Saldo obtido:', data);\n            return data.balance;\n        } catch (error) {\n            console.error('API: Erro na chamada getBalance:', error);\n            throw error;\n        }\n    },\n    async setBalance (data) {\n        console.log('API: Atualizando saldo:', data);\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/set-balance\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            if (!response.ok) {\n                console.error('API: Erro ao atualizar saldo:', response.status, response.statusText);\n                throw new Error('Failed to set balance');\n            }\n            const result = await response.json();\n            console.log('API: Saldo atualizado com sucesso:', result);\n            return result;\n        } catch (error) {\n            console.error('API: Erro na chamada setBalance:', error);\n            throw error;\n        }\n    },\n    async updateBalancesAfterTransaction (senderId, receiverId, amount) {\n        console.log('API: Iniciando atualização de saldos:', {\n            senderId,\n            receiverId,\n            amount\n        });\n        try {\n            // Get current balances\n            const senderBalance = await this.getBalance(senderId);\n            const receiverBalance = await this.getBalance(receiverId);\n            console.log('API: Saldos atuais:', {\n                senderBalance,\n                receiverBalance\n            });\n            // Update sender's balance (subtract amount)\n            const newSenderBalance = senderBalance - amount;\n            await this.setBalance({\n                user_id: senderId,\n                balance: newSenderBalance\n            });\n            // Update receiver's balance (add amount)\n            await this.setBalance({\n                user_id: receiverId,\n                balance: receiverBalance + amount\n            });\n            // Return updated balances\n            const updatedSenderBalance = await this.getBalance(senderId);\n            const updatedReceiverBalance = await this.getBalance(receiverId);\n            console.log('API: Saldos atualizados:', {\n                updatedSenderBalance,\n                updatedReceiverBalance\n            });\n            return {\n                senderBalance: updatedSenderBalance,\n                receiverBalance: updatedReceiverBalance\n            };\n        } catch (error) {\n            console.error('API: Erro ao atualizar saldos:', error);\n            throw error;\n        }\n    },\n    async transferMoney (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/pos\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Transfer failed');\n        }\n        return response.json();\n    },\n    async transferPix (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/pix\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('PIX transfer failed');\n        }\n        return response.json();\n    },\n    async payLink (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/link\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Link payment failed');\n        }\n        return response.json();\n    },\n    async cardPayment (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/card\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Card payment failed');\n        }\n        return response.json();\n    },\n    async createReceivable (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/receivables\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Failed to create receivable');\n        }\n        return response.json();\n    },\n    async getUserInfo (identifier) {\n        // Se for um número, usa o endpoint /users/{id}\n        if (!isNaN(Number(identifier))) {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(identifier), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error('Failed to get user info');\n            }\n            return response.json();\n        }\n        // Se não for número, primeiro busca o ID usando /users/search\n        const searchResponse = await fetch(\"\".concat(API_BASE_URL, \"/users/search?query=\").concat(encodeURIComponent(identifier)), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!searchResponse.ok) {\n            throw new Error('Failed to search user');\n        }\n        const searchData = await searchResponse.json();\n        console.log('Resposta da busca de usuário:', searchData);\n        let userId;\n        // Se retornar array, pega o primeiro usuário com id\n        if (Array.isArray(searchData) && searchData.length > 0 && searchData[0].id) {\n            userId = searchData[0].id;\n        } else if (searchData && searchData.id) {\n            userId = searchData.id;\n        } else {\n            throw new Error('Usuário não encontrado');\n        }\n        // Agora busca os detalhes completos usando o ID\n        const userResponse = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(userId), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!userResponse.ok) {\n            throw new Error('Failed to get user details');\n        }\n        return userResponse.json();\n    },\n    async createUser (data) {\n        try {\n            const response = await fetch('https://qe-api.services.staging.cloudwalk.network/users/new', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            const res = await response.json();\n            // Se o handle já existe, tenta criar com um sufixo aleatório\n            if (res.error && res.error.includes('handle has already been taken')) {\n                const newHandle = \"\".concat(data.handle).concat(Math.floor(Math.random() * 1000));\n                return this.createUser({\n                    handle: newHandle\n                });\n            }\n            if (!response.ok) {\n                console.error('Erro ao criar usuário:', res);\n                throw new Error(res.message || 'Erro ao criar usuário');\n            }\n            return res;\n        } catch (err) {\n            console.error('Erro de rede ao criar usuário:', err);\n            throw err;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLElBQUlyQyxNQUFNcUMsSUFBSU8sT0FBTyxJQUFJO1lBQ2pDO1lBQ0EsT0FBT1A7UUFDVCxFQUFFLE9BQU9RLEtBQUs7WUFDWnZELFFBQVFPLEtBQUssQ0FBQyxrQ0FBa0NnRDtZQUNoRCxNQUFNQTtRQUNSO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvY2xhcmFyaWJlaXJvL0dJVFMvUUUgLSBDaGFsbGVuZ2Uvc3JjL3NlcnZpY2VzL2FwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9xZS1hcGkuc2VydmljZXMuc3RhZ2luZy5jbG91ZHdhbGsubmV0d29yayc7XG5cbmludGVyZmFjZSBUcmFuc2ZlclJlcXVlc3Qge1xuICB0b191c2VyX2lkOiBudW1iZXI7XG4gIGFtb3VudDogbnVtYmVyO1xuICBwYXltZW50X21ldGhvZDogJ2RlYml0JyB8ICdjcmVkaXQnO1xufVxuXG5pbnRlcmZhY2UgUGl4VHJhbnNmZXJSZXF1ZXN0IHtcbiAgZnJvbV91c2VyX2lkPzogbnVtYmVyO1xuICB0b191c2VyX2lkOiBudW1iZXI7XG4gIGFtb3VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU2V0QmFsYW5jZVJlcXVlc3Qge1xuICB1c2VyX2lkOiBudW1iZXI7XG4gIGJhbGFuY2U6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFVzZXJSZXNwb25zZSB7XG4gIGlkOiBudW1iZXI7XG4gIGhhbmRsZTogc3RyaW5nO1xuICBiYWxhbmNlOiBudW1iZXI7XG4gIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgYXBpID0ge1xuICBhc3luYyBnZXRCYWxhbmNlKHVzZXJJZDogbnVtYmVyKSB7XG4gICAgY29uc29sZS5sb2coJ0FQSTogQnVzY2FuZG8gc2FsZG8gcGFyYSB1c2VySWQ6JywgdXNlcklkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBUEk6IEVycm8gYW8gYnVzY2FyIHNhbGRvOicsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGJhbGFuY2UnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEk6IFNhbGRvIG9idGlkbzonLCBkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhLmJhbGFuY2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogRXJybyBuYSBjaGFtYWRhIGdldEJhbGFuY2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIHNldEJhbGFuY2UoZGF0YTogU2V0QmFsYW5jZVJlcXVlc3QpIHtcbiAgICBjb25zb2xlLmxvZygnQVBJOiBBdHVhbGl6YW5kbyBzYWxkbzonLCBkYXRhKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJzL3NldC1iYWxhbmNlYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogRXJybyBhbyBhdHVhbGl6YXIgc2FsZG86JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2V0IGJhbGFuY2UnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEk6IFNhbGRvIGF0dWFsaXphZG8gY29tIHN1Y2Vzc286JywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogRXJybyBuYSBjaGFtYWRhIHNldEJhbGFuY2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIHVwZGF0ZUJhbGFuY2VzQWZ0ZXJUcmFuc2FjdGlvbihzZW5kZXJJZDogbnVtYmVyLCByZWNlaXZlcklkOiBudW1iZXIsIGFtb3VudDogbnVtYmVyKSB7XG4gICAgY29uc29sZS5sb2coJ0FQSTogSW5pY2lhbmRvIGF0dWFsaXphw6fDo28gZGUgc2FsZG9zOicsIHsgc2VuZGVySWQsIHJlY2VpdmVySWQsIGFtb3VudCB9KTtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgYmFsYW5jZXNcbiAgICAgIGNvbnN0IHNlbmRlckJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2Uoc2VuZGVySWQpO1xuICAgICAgY29uc3QgcmVjZWl2ZXJCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKHJlY2VpdmVySWQpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSTogU2FsZG9zIGF0dWFpczonLCB7IHNlbmRlckJhbGFuY2UsIHJlY2VpdmVyQmFsYW5jZSB9KTtcblxuICAgICAgLy8gVXBkYXRlIHNlbmRlcidzIGJhbGFuY2UgKHN1YnRyYWN0IGFtb3VudClcbiAgICAgIGNvbnN0IG5ld1NlbmRlckJhbGFuY2UgPSBzZW5kZXJCYWxhbmNlIC0gYW1vdW50O1xuICAgICAgYXdhaXQgdGhpcy5zZXRCYWxhbmNlKHtcbiAgICAgICAgdXNlcl9pZDogc2VuZGVySWQsXG4gICAgICAgIGJhbGFuY2U6IG5ld1NlbmRlckJhbGFuY2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgcmVjZWl2ZXIncyBiYWxhbmNlIChhZGQgYW1vdW50KVxuICAgICAgYXdhaXQgdGhpcy5zZXRCYWxhbmNlKHtcbiAgICAgICAgdXNlcl9pZDogcmVjZWl2ZXJJZCxcbiAgICAgICAgYmFsYW5jZTogcmVjZWl2ZXJCYWxhbmNlICsgYW1vdW50XG4gICAgICB9KTtcblxuICAgICAgLy8gUmV0dXJuIHVwZGF0ZWQgYmFsYW5jZXNcbiAgICAgIGNvbnN0IHVwZGF0ZWRTZW5kZXJCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKHNlbmRlcklkKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRSZWNlaXZlckJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UocmVjZWl2ZXJJZCk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJOiBTYWxkb3MgYXR1YWxpemFkb3M6JywgeyB1cGRhdGVkU2VuZGVyQmFsYW5jZSwgdXBkYXRlZFJlY2VpdmVyQmFsYW5jZSB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VuZGVyQmFsYW5jZTogdXBkYXRlZFNlbmRlckJhbGFuY2UsXG4gICAgICAgIHJlY2VpdmVyQmFsYW5jZTogdXBkYXRlZFJlY2VpdmVyQmFsYW5jZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJOiBFcnJvIGFvIGF0dWFsaXphciBzYWxkb3M6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIHRyYW5zZmVyTW9uZXkoZGF0YTogVHJhbnNmZXJSZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3BheS9wb3NgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNmZXIgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyB0cmFuc2ZlclBpeChkYXRhOiBQaXhUcmFuc2ZlclJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vcGF5L3BpeGAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQSVggdHJhbnNmZXIgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBwYXlMaW5rKGRhdGE6IGFueSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9wYXkvbGlua2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5rIHBheW1lbnQgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBjYXJkUGF5bWVudChkYXRhOiBhbnkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vcGF5L2NhcmRgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FyZCBwYXltZW50IGZhaWxlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgY3JlYXRlUmVjZWl2YWJsZShkYXRhOiBhbnkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vcmVjZWl2YWJsZXNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSByZWNlaXZhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBnZXRVc2VySW5mbyhpZGVudGlmaWVyOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIC8vIFNlIGZvciB1bSBuw7ptZXJvLCB1c2EgbyBlbmRwb2ludCAvdXNlcnMve2lkfVxuICAgIGlmICghaXNOYU4oTnVtYmVyKGlkZW50aWZpZXIpKSkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJzLyR7aWRlbnRpZmllcn1gLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHVzZXIgaW5mbycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cblxuICAgIC8vIFNlIG7Do28gZm9yIG7Dum1lcm8sIHByaW1laXJvIGJ1c2NhIG8gSUQgdXNhbmRvIC91c2Vycy9zZWFyY2hcbiAgICBjb25zdCBzZWFyY2hSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vdXNlcnMvc2VhcmNoP3F1ZXJ5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkZW50aWZpZXIpfWAsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgaWYgKCFzZWFyY2hSZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2VhcmNoIHVzZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWFyY2hEYXRhID0gYXdhaXQgc2VhcmNoUmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdSZXNwb3N0YSBkYSBidXNjYSBkZSB1c3XDoXJpbzonLCBzZWFyY2hEYXRhKTtcblxuICAgIGxldCB1c2VySWQ6IG51bWJlcjtcbiAgICAvLyBTZSByZXRvcm5hciBhcnJheSwgcGVnYSBvIHByaW1laXJvIHVzdcOhcmlvIGNvbSBpZFxuICAgIGlmIChBcnJheS5pc0FycmF5KHNlYXJjaERhdGEpICYmIHNlYXJjaERhdGEubGVuZ3RoID4gMCAmJiBzZWFyY2hEYXRhWzBdLmlkKSB7XG4gICAgICB1c2VySWQgPSBzZWFyY2hEYXRhWzBdLmlkO1xuICAgIH1cbiAgICAvLyBTZSByZXRvcm5hciBvYmpldG8gw7puaWNvXG4gICAgZWxzZSBpZiAoc2VhcmNoRGF0YSAmJiBzZWFyY2hEYXRhLmlkKSB7XG4gICAgICB1c2VySWQgPSBzZWFyY2hEYXRhLmlkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXN1w6FyaW8gbsOjbyBlbmNvbnRyYWRvJyk7XG4gICAgfVxuXG4gICAgLy8gQWdvcmEgYnVzY2Egb3MgZGV0YWxoZXMgY29tcGxldG9zIHVzYW5kbyBvIElEXG4gICAgY29uc3QgdXNlclJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH1gLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmICghdXNlclJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgdXNlciBkZXRhaWxzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVzZXJSZXNwb25zZS5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgY3JlYXRlVXNlcihkYXRhOiB7IGhhbmRsZTogc3RyaW5nIH0pOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwczovL3FlLWFwaS5zZXJ2aWNlcy5zdGFnaW5nLmNsb3Vkd2Fsay5uZXR3b3JrL3VzZXJzL25ldycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICAvLyBTZSBvIGhhbmRsZSBqw6EgZXhpc3RlLCB0ZW50YSBjcmlhciBjb20gdW0gc3VmaXhvIGFsZWF0w7NyaW9cbiAgICAgIGlmIChyZXMuZXJyb3IgJiYgcmVzLmVycm9yLmluY2x1ZGVzKCdoYW5kbGUgaGFzIGFscmVhZHkgYmVlbiB0YWtlbicpKSB7XG4gICAgICAgIGNvbnN0IG5ld0hhbmRsZSA9IGAke2RhdGEuaGFuZGxlfSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCl9YDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXNlcih7IGhhbmRsZTogbmV3SGFuZGxlIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gYW8gY3JpYXIgdXN1w6FyaW86JywgcmVzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5tZXNzYWdlIHx8ICdFcnJvIGFvIGNyaWFyIHVzdcOhcmlvJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJybyBkZSByZWRlIGFvIGNyaWFyIHVzdcOhcmlvOicsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59OyAiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwiYXBpIiwiZ2V0QmFsYW5jZSIsInVzZXJJZCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIm9rIiwiZXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImJhbGFuY2UiLCJzZXRCYWxhbmNlIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bHQiLCJ1cGRhdGVCYWxhbmNlc0FmdGVyVHJhbnNhY3Rpb24iLCJzZW5kZXJJZCIsInJlY2VpdmVySWQiLCJhbW91bnQiLCJzZW5kZXJCYWxhbmNlIiwicmVjZWl2ZXJCYWxhbmNlIiwibmV3U2VuZGVyQmFsYW5jZSIsInVzZXJfaWQiLCJ1cGRhdGVkU2VuZGVyQmFsYW5jZSIsInVwZGF0ZWRSZWNlaXZlckJhbGFuY2UiLCJ0cmFuc2Zlck1vbmV5IiwidHJhbnNmZXJQaXgiLCJwYXlMaW5rIiwiY2FyZFBheW1lbnQiLCJjcmVhdGVSZWNlaXZhYmxlIiwiZ2V0VXNlckluZm8iLCJpZGVudGlmaWVyIiwiaXNOYU4iLCJOdW1iZXIiLCJzZWFyY2hSZXNwb25zZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInNlYXJjaERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpZCIsInVzZXJSZXNwb25zZSIsImNyZWF0ZVVzZXIiLCJyZXMiLCJpbmNsdWRlcyIsIm5ld0hhbmRsZSIsIk1hdGgiLCJoYW5kbGUiLCJmbG9vciIsInJhbmRvbSIsIm1lc3NhZ2UiLCJlcnIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api.ts\n"));

/***/ })

});