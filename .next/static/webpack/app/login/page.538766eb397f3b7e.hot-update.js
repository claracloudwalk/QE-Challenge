"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api)\n/* harmony export */ });\n/* harmony import */ var _userDb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./userDb */ \"(app-pages-browser)/./src/services/userDb.ts\");\n\nconst API_BASE_URL = 'https://qe-api.services.staging.cloudwalk.network';\nconst api = {\n    async getBalance (userId) {\n        console.log('API: Buscando saldo para userId:', userId);\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(userId), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                console.error('API: Erro ao buscar saldo:', response.status, response.statusText);\n                throw new Error('Failed to fetch balance');\n            }\n            const data = await response.json();\n            console.log('API: Saldo obtido:', data);\n            return data.balance;\n        } catch (error) {\n            console.error('API: Erro na chamada getBalance:', error);\n            throw error;\n        }\n    },\n    async setBalance (data) {\n        console.log('API: Atualizando saldo:', data);\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/set-balance\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            if (!response.ok) {\n                console.error('API: Erro ao atualizar saldo:', response.status, response.statusText);\n                throw new Error('Failed to set balance');\n            }\n            const result = await response.json();\n            console.log('API: Saldo atualizado com sucesso:', result);\n            return result;\n        } catch (error) {\n            console.error('API: Erro na chamada setBalance:', error);\n            throw error;\n        }\n    },\n    async updateBalancesAfterTransaction (senderId, receiverId, amount) {\n        console.log('API: Iniciando atualização de saldos:', {\n            senderId,\n            receiverId,\n            amount\n        });\n        try {\n            // Get current balances\n            const senderBalance = await this.getBalance(senderId);\n            const receiverBalance = await this.getBalance(receiverId);\n            console.log('API: Saldos atuais:', {\n                senderBalance,\n                receiverBalance\n            });\n            // Update sender's balance (subtract amount)\n            const newSenderBalance = senderBalance - amount;\n            await this.setBalance({\n                user_id: senderId,\n                balance: newSenderBalance\n            });\n            // Update receiver's balance (add amount)\n            await this.setBalance({\n                user_id: receiverId,\n                balance: receiverBalance + amount\n            });\n            // Return updated balances\n            const updatedSenderBalance = await this.getBalance(senderId);\n            const updatedReceiverBalance = await this.getBalance(receiverId);\n            console.log('API: Saldos atualizados:', {\n                updatedSenderBalance,\n                updatedReceiverBalance\n            });\n            return {\n                senderBalance: updatedSenderBalance,\n                receiverBalance: updatedReceiverBalance\n            };\n        } catch (error) {\n            console.error('API: Erro ao atualizar saldos:', error);\n            throw error;\n        }\n    },\n    async transferMoney (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/pos\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Transfer failed');\n        }\n        return response.json();\n    },\n    async transferPix (data) {\n        console.log('Iniciando transferência PIX com dados:', {\n            from_user_id: data.from_user_id,\n            to_user_id: data.to_user_id,\n            amount: data.amount\n        });\n        const requestBody = {\n            from_user_id: Number(data.from_user_id),\n            to_user_id: Number(data.to_user_id),\n            amount: Number(data.amount)\n        };\n        console.log('Request body formatado:', requestBody);\n        console.log('URL da requisição:', \"\".concat(API_BASE_URL, \"/pay/pix\"));\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/pix\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            },\n            body: JSON.stringify(requestBody)\n        });\n        if (!response.ok) {\n            console.error('Erro na transferência PIX:', {\n                status: response.status,\n                statusText: response.statusText,\n                url: response.url\n            });\n            throw new Error('PIX transfer failed');\n        }\n        return response.json();\n    },\n    async payLink (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/link\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Link payment failed');\n        }\n        return response.json();\n    },\n    async cardPayment (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/card_payment\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Card payment failed');\n        }\n        return response.json();\n    },\n    async createReceivable (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/receivables\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Failed to create receivable');\n        }\n        return response.json();\n    },\n    async getUserInfo (identifier) {\n        console.log('getUserInfo chamado com:', identifier);\n        const localUser = _userDb__WEBPACK_IMPORTED_MODULE_0__.userDb.getUserByIdentifier(identifier);\n        if (localUser) {\n            console.log('Usuário encontrado no banco local:', localUser);\n            try {\n                // Busca os detalhes completos (incluindo saldo) da API usando o ID\n                const response = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(localUser.id), {\n                    method: 'GET',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    }\n                });\n                if (!response.ok) {\n                    console.warn(\"Failed to get user details from API for ID \".concat(localUser.id, \", falling back to direct API search\"));\n                } else {\n                    return response.json();\n                }\n            } catch (error) {\n                console.warn('Error fetching user details from API, falling back to direct API search:', error);\n            }\n        }\n        // Se não encontrou no banco local ou falhou ao buscar detalhes, tenta a API diretamente\n        // Se for um número, usa o endpoint /users/{id}\n        if (!isNaN(Number(identifier))) {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(identifier), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error('Failed to get user info');\n            }\n            return response.json();\n        }\n        // Se não for número, primeiro busca o ID usando /users/search\n        const searchResponse = await fetch(\"\".concat(API_BASE_URL, \"/users/search?query=\").concat(encodeURIComponent(identifier)), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!searchResponse.ok) {\n            throw new Error('Failed to search user');\n        }\n        const searchData = await searchResponse.json();\n        console.log('Resposta da busca de usuário:', searchData);\n        let userId;\n        // Se retornar array, pega o primeiro usuário com id\n        if (Array.isArray(searchData) && searchData.length > 0 && searchData[0].id) {\n            userId = searchData[0].id;\n        } else if (searchData && searchData.id) {\n            userId = searchData.id;\n        } else {\n            throw new Error('Usuário não encontrado');\n        }\n        // Agora busca os detalhes completos usando o ID\n        const userResponse = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(userId), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!userResponse.ok) {\n            throw new Error('Failed to get user details');\n        }\n        return userResponse.json();\n    },\n    async createUser (data) {\n        try {\n            const response = await fetch('https://qe-api.services.staging.cloudwalk.network/users/new', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            const res = await response.json();\n            // Se o handle já existe, tenta criar com um sufixo aleatório\n            if (res.error && res.error.includes('handle has already been taken')) {\n                const newHandle = \"\".concat(data.handle).concat(Math.floor(Math.random() * 1000));\n                return this.createUser({\n                    handle: newHandle\n                });\n            }\n            if (!response.ok) {\n                console.error('Erro ao criar usuário:', res);\n                throw new Error(res.message || 'Erro ao criar usuário');\n            }\n            return res;\n        } catch (err) {\n            console.error('Erro de rede ao criar usuário:', err);\n            throw err;\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFFbEMsTUFBTUMsZUFBZTtBQTJCZCxNQUFNQyxNQUFNO0lBQ2pCLE1BQU1DLFlBQVdDLE1BQWM7UUFDN0JDLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0NGO1FBQ2hELElBQUk7WUFDRixNQUFNRyxXQUFXLE1BQU1DLE1BQU0sR0FBeUJKLE9BQXRCSCxjQUFhLFdBQWdCLE9BQVBHLFNBQVU7Z0JBQzlESyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBLElBQUksQ0FBQ0gsU0FBU0ksRUFBRSxFQUFFO2dCQUNoQk4sUUFBUU8sS0FBSyxDQUFDLDhCQUE4QkwsU0FBU00sTUFBTSxFQUFFTixTQUFTTyxVQUFVO2dCQUNoRixNQUFNLElBQUlDLE1BQU07WUFDbEI7WUFFQSxNQUFNQyxPQUFPLE1BQU1ULFNBQVNVLElBQUk7WUFDaENaLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JVO1lBQ2xDLE9BQU9BLEtBQUtFLE9BQU87UUFDckIsRUFBRSxPQUFPTixPQUFPO1lBQ2RQLFFBQVFPLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU1PLFlBQVdILElBQXVCO1FBQ3RDWCxRQUFRQyxHQUFHLENBQUMsMkJBQTJCVTtRQUN2QyxJQUFJO1lBQ0YsTUFBTVQsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJQLGNBQWEsdUJBQXFCO2dCQUNoRVEsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBVSxNQUFNQyxLQUFLQyxTQUFTLENBQUNOO1lBQ3ZCO1lBQ0EsSUFBSSxDQUFDVCxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCTixRQUFRTyxLQUFLLENBQUMsaUNBQWlDTCxTQUFTTSxNQUFNLEVBQUVOLFNBQVNPLFVBQVU7Z0JBQ25GLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUNBLE1BQU1RLFNBQVMsTUFBTWhCLFNBQVNVLElBQUk7WUFDbENaLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0NpQjtZQUNsRCxPQUFPQTtRQUNULEVBQUUsT0FBT1gsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMsb0NBQW9DQTtZQUNsRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNWSxnQ0FBK0JDLFFBQWdCLEVBQUVDLFVBQWtCLEVBQUVDLE1BQWM7UUFDdkZ0QixRQUFRQyxHQUFHLENBQUMseUNBQXlDO1lBQUVtQjtZQUFVQztZQUFZQztRQUFPO1FBQ3BGLElBQUk7WUFDRix1QkFBdUI7WUFDdkIsTUFBTUMsZ0JBQWdCLE1BQU0sSUFBSSxDQUFDekIsVUFBVSxDQUFDc0I7WUFDNUMsTUFBTUksa0JBQWtCLE1BQU0sSUFBSSxDQUFDMUIsVUFBVSxDQUFDdUI7WUFDOUNyQixRQUFRQyxHQUFHLENBQUMsdUJBQXVCO2dCQUFFc0I7Z0JBQWVDO1lBQWdCO1lBRXBFLDRDQUE0QztZQUM1QyxNQUFNQyxtQkFBbUJGLGdCQUFnQkQ7WUFDekMsTUFBTSxJQUFJLENBQUNSLFVBQVUsQ0FBQztnQkFDcEJZLFNBQVNOO2dCQUNUUCxTQUFTWTtZQUNYO1lBRUEseUNBQXlDO1lBQ3pDLE1BQU0sSUFBSSxDQUFDWCxVQUFVLENBQUM7Z0JBQ3BCWSxTQUFTTDtnQkFDVFIsU0FBU1csa0JBQWtCRjtZQUM3QjtZQUVBLDBCQUEwQjtZQUMxQixNQUFNSyx1QkFBdUIsTUFBTSxJQUFJLENBQUM3QixVQUFVLENBQUNzQjtZQUNuRCxNQUFNUSx5QkFBeUIsTUFBTSxJQUFJLENBQUM5QixVQUFVLENBQUN1QjtZQUNyRHJCLFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEI7Z0JBQUUwQjtnQkFBc0JDO1lBQXVCO1lBRXZGLE9BQU87Z0JBQ0xMLGVBQWVJO2dCQUNmSCxpQkFBaUJJO1lBQ25CO1FBQ0YsRUFBRSxPQUFPckIsT0FBTztZQUNkUCxRQUFRTyxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNc0IsZUFBY2xCLElBQXFCO1FBQ3ZDLE1BQU1ULFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiUCxjQUFhLGFBQVc7WUFDdERRLFFBQVE7WUFDUkMsU0FBUztnQkFDUCxnQkFBZ0I7WUFDbEI7WUFDQVUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDTjtRQUN2QjtRQUVBLElBQUksQ0FBQ1QsU0FBU0ksRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUksTUFBTTtRQUNsQjtRQUVBLE9BQU9SLFNBQVNVLElBQUk7SUFDdEI7SUFFQSxNQUFNa0IsYUFBWW5CLElBQXdCO1FBQ3hDWCxRQUFRQyxHQUFHLENBQUMsMENBQTBDO1lBQ2xEOEIsY0FBY3BCLEtBQUtvQixZQUFZO1lBQy9CQyxZQUFZckIsS0FBS3FCLFVBQVU7WUFDM0JWLFFBQVFYLEtBQUtXLE1BQU07UUFDdkI7UUFFQSxNQUFNVyxjQUFjO1lBQ2hCRixjQUFjRyxPQUFPdkIsS0FBS29CLFlBQVk7WUFDdENDLFlBQVlFLE9BQU92QixLQUFLcUIsVUFBVTtZQUNsQ1YsUUFBUVksT0FBT3ZCLEtBQUtXLE1BQU07UUFDOUI7UUFFQXRCLFFBQVFDLEdBQUcsQ0FBQywyQkFBMkJnQztRQUN2Q2pDLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0IsR0FBZ0IsT0FBYkwsY0FBYTtRQUVsRCxNQUFNTSxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYlAsY0FBYSxhQUFXO1lBQ3BEUSxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ0wsZ0JBQWdCO2dCQUNoQixVQUFVO1lBQ2Q7WUFDQVUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDZ0I7UUFDekI7UUFFQSxJQUFJLENBQUMvQixTQUFTSSxFQUFFLEVBQUU7WUFDZE4sUUFBUU8sS0FBSyxDQUFDLDhCQUE4QjtnQkFDeENDLFFBQVFOLFNBQVNNLE1BQU07Z0JBQ3ZCQyxZQUFZUCxTQUFTTyxVQUFVO2dCQUMvQjBCLEtBQUtqQyxTQUFTaUMsR0FBRztZQUNyQjtZQUNBLE1BQU0sSUFBSXpCLE1BQU07UUFDcEI7UUFFQSxPQUFPUixTQUFTVSxJQUFJO0lBQ3RCO0lBRUEsTUFBTXdCLFNBQVF6QixJQUFTO1FBQ3JCLE1BQU1ULFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiUCxjQUFhLGNBQVk7WUFDdkRRLFFBQVE7WUFDUkMsU0FBUztnQkFDUCxnQkFBZ0I7WUFDbEI7WUFDQVUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDTjtRQUN2QjtRQUVBLElBQUksQ0FBQ1QsU0FBU0ksRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUksTUFBTTtRQUNsQjtRQUVBLE9BQU9SLFNBQVNVLElBQUk7SUFDdEI7SUFFQSxNQUFNeUIsYUFBWTFCLElBQVM7UUFDekIsTUFBTVQsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJQLGNBQWEsa0JBQWdCO1lBQzNEUSxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1lBQ0FVLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ047UUFDdkI7UUFFQSxJQUFJLENBQUNULFNBQVNJLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFFQSxPQUFPUixTQUFTVSxJQUFJO0lBQ3RCO0lBRUEsTUFBTTBCLGtCQUFpQjNCLElBQVM7UUFDOUIsTUFBTVQsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWJQLGNBQWEsaUJBQWU7WUFDMURRLFFBQVE7WUFDUkMsU0FBUztnQkFDUCxnQkFBZ0I7WUFDbEI7WUFDQVUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDTjtRQUN2QjtRQUVBLElBQUksQ0FBQ1QsU0FBU0ksRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUksTUFBTTtRQUNsQjtRQUVBLE9BQU9SLFNBQVNVLElBQUk7SUFDdEI7SUFFQSxNQUFNMkIsYUFBWUMsVUFBa0I7UUFDbEN4QyxRQUFRQyxHQUFHLENBQUMsNEJBQTRCdUM7UUFDeEMsTUFBTUMsWUFBWTlDLDJDQUFNQSxDQUFDK0MsbUJBQW1CLENBQUNGO1FBQzdDLElBQUlDLFdBQVc7WUFDYnpDLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0N3QztZQUNsRCxJQUFJO2dCQUNGLG1FQUFtRTtnQkFDbkUsTUFBTXZDLFdBQVcsTUFBTUMsTUFBTSxHQUF5QnNDLE9BQXRCN0MsY0FBYSxXQUFzQixPQUFiNkMsVUFBVUUsRUFBRSxHQUFJO29CQUNwRXZDLFFBQVE7b0JBQ1JDLFNBQVM7d0JBQ1AsZ0JBQWdCO29CQUNsQjtnQkFDRjtnQkFFQSxJQUFJLENBQUNILFNBQVNJLEVBQUUsRUFBRTtvQkFDaEJOLFFBQVE0QyxJQUFJLENBQUMsOENBQTJELE9BQWJILFVBQVVFLEVBQUUsRUFBQztnQkFDMUUsT0FBTztvQkFDTCxPQUFPekMsU0FBU1UsSUFBSTtnQkFDdEI7WUFDRixFQUFFLE9BQU9MLE9BQU87Z0JBQ2RQLFFBQVE0QyxJQUFJLENBQUMsNEVBQTRFckM7WUFDM0Y7UUFDRjtRQUVBLHdGQUF3RjtRQUN4RiwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDc0MsTUFBTVgsT0FBT00sY0FBYztZQUM5QixNQUFNdEMsV0FBVyxNQUFNQyxNQUFNLEdBQXlCcUMsT0FBdEI1QyxjQUFhLFdBQW9CLE9BQVg0QyxhQUFjO2dCQUNsRXBDLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtZQUNGO1lBRUEsSUFBSSxDQUFDSCxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUksTUFBTTtZQUNsQjtZQUVBLE9BQU9SLFNBQVNVLElBQUk7UUFDdEI7UUFFQSw4REFBOEQ7UUFDOUQsTUFBTWtDLGlCQUFpQixNQUFNM0MsTUFBTSxHQUFzQzRDLE9BQW5DbkQsY0FBYSx3QkFBcUQsT0FBL0JtRCxtQkFBbUJQLGNBQWU7WUFDekdwQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJLENBQUN5QyxlQUFleEMsRUFBRSxFQUFFO1lBQ3RCLE1BQU0sSUFBSUksTUFBTTtRQUNsQjtRQUVBLE1BQU1zQyxhQUFhLE1BQU1GLGVBQWVsQyxJQUFJO1FBQzVDWixRQUFRQyxHQUFHLENBQUMsaUNBQWlDK0M7UUFFN0MsSUFBSWpEO1FBQ0osb0RBQW9EO1FBQ3BELElBQUlrRCxNQUFNQyxPQUFPLENBQUNGLGVBQWVBLFdBQVdHLE1BQU0sR0FBRyxLQUFLSCxVQUFVLENBQUMsRUFBRSxDQUFDTCxFQUFFLEVBQUU7WUFDMUU1QyxTQUFTaUQsVUFBVSxDQUFDLEVBQUUsQ0FBQ0wsRUFBRTtRQUMzQixPQUVLLElBQUlLLGNBQWNBLFdBQVdMLEVBQUUsRUFBRTtZQUNwQzVDLFNBQVNpRCxXQUFXTCxFQUFFO1FBQ3hCLE9BQ0s7WUFDSCxNQUFNLElBQUlqQyxNQUFNO1FBQ2xCO1FBRUEsZ0RBQWdEO1FBQ2hELE1BQU0wQyxlQUFlLE1BQU1qRCxNQUFNLEdBQXlCSixPQUF0QkgsY0FBYSxXQUFnQixPQUFQRyxTQUFVO1lBQ2xFSyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJLENBQUMrQyxhQUFhOUMsRUFBRSxFQUFFO1lBQ3BCLE1BQU0sSUFBSUksTUFBTTtRQUNsQjtRQUVBLE9BQU8wQyxhQUFheEMsSUFBSTtJQUMxQjtJQUVBLE1BQU15QyxZQUFXMUMsSUFBd0I7UUFDdkMsSUFBSTtZQUNGLE1BQU1ULFdBQVcsTUFBTUMsTUFBTSwrREFBK0Q7Z0JBQzFGQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FVLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ047WUFDdkI7WUFDQSxNQUFNMkMsTUFBTSxNQUFNcEQsU0FBU1UsSUFBSTtZQUUvQiw2REFBNkQ7WUFDN0QsSUFBSTBDLElBQUkvQyxLQUFLLElBQUkrQyxJQUFJL0MsS0FBSyxDQUFDZ0QsUUFBUSxDQUFDLGtDQUFrQztnQkFDcEUsTUFBTUMsWUFBWSxHQUFpQkMsT0FBZDlDLEtBQUsrQyxNQUFNLEVBQW9DLE9BQWpDRCxLQUFLRSxLQUFLLENBQUNGLEtBQUtHLE1BQU0sS0FBSztnQkFDOUQsT0FBTyxJQUFJLENBQUNQLFVBQVUsQ0FBQztvQkFBRUssUUFBUUY7Z0JBQVU7WUFDN0M7WUFFQSxJQUFJLENBQUN0RCxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCTixRQUFRTyxLQUFLLENBQUMsMEJBQTBCK0M7Z0JBQ3hDLE1BQU0sSUFBSTVDLE1BQU00QyxJQUFJTyxPQUFPLElBQUk7WUFDakM7WUFDQSxPQUFPUDtRQUNULEVBQUUsT0FBT1EsS0FBSztZQUNaOUQsUUFBUU8sS0FBSyxDQUFDLGtDQUFrQ3VEO1lBQ2hELE1BQU1BO1FBQ1I7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jbGFyYXJpYmVpcm8vR0lUUy9RRSAtIENoYWxsZW5nZS9zcmMvc2VydmljZXMvYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZXJEYiB9IGZyb20gJy4vdXNlckRiJztcblxuY29uc3QgQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vcWUtYXBpLnNlcnZpY2VzLnN0YWdpbmcuY2xvdWR3YWxrLm5ldHdvcmsnO1xuXG5pbnRlcmZhY2UgVHJhbnNmZXJSZXF1ZXN0IHtcbiAgdG9fdXNlcl9pZDogbnVtYmVyO1xuICBhbW91bnQ6IG51bWJlcjtcbiAgcGF5bWVudF9tZXRob2Q6ICdkZWJpdCcgfCAnY3JlZGl0Jztcbn1cblxuaW50ZXJmYWNlIFBpeFRyYW5zZmVyUmVxdWVzdCB7XG4gIGZyb21fdXNlcl9pZD86IG51bWJlcjtcbiAgdG9fdXNlcl9pZDogbnVtYmVyO1xuICBhbW91bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFNldEJhbGFuY2VSZXF1ZXN0IHtcbiAgdXNlcl9pZDogbnVtYmVyO1xuICBiYWxhbmNlOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBVc2VyUmVzcG9uc2Uge1xuICBpZDogbnVtYmVyO1xuICBoYW5kbGU6IHN0cmluZztcbiAgYmFsYW5jZTogbnVtYmVyO1xuICBtZXNzYWdlPzogc3RyaW5nO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGFwaSA9IHtcbiAgYXN5bmMgZ2V0QmFsYW5jZSh1c2VySWQ6IG51bWJlcikge1xuICAgIGNvbnNvbGUubG9nKCdBUEk6IEJ1c2NhbmRvIHNhbGRvIHBhcmEgdXNlcklkOicsIHVzZXJJZCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQVBJOiBFcnJvIGFvIGJ1c2NhciBzYWxkbzonLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBiYWxhbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJOiBTYWxkbyBvYnRpZG86JywgZGF0YSk7XG4gICAgICByZXR1cm4gZGF0YS5iYWxhbmNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBUEk6IEVycm8gbmEgY2hhbWFkYSBnZXRCYWxhbmNlOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICBhc3luYyBzZXRCYWxhbmNlKGRhdGE6IFNldEJhbGFuY2VSZXF1ZXN0KSB7XG4gICAgY29uc29sZS5sb2coJ0FQSTogQXR1YWxpemFuZG8gc2FsZG86JywgZGF0YSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS91c2Vycy9zZXQtYmFsYW5jZWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBUEk6IEVycm8gYW8gYXR1YWxpemFyIHNhbGRvOicsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNldCBiYWxhbmNlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJOiBTYWxkbyBhdHVhbGl6YWRvIGNvbSBzdWNlc3NvOicsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBUEk6IEVycm8gbmEgY2hhbWFkYSBzZXRCYWxhbmNlOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICBhc3luYyB1cGRhdGVCYWxhbmNlc0FmdGVyVHJhbnNhY3Rpb24oc2VuZGVySWQ6IG51bWJlciwgcmVjZWl2ZXJJZDogbnVtYmVyLCBhbW91bnQ6IG51bWJlcikge1xuICAgIGNvbnNvbGUubG9nKCdBUEk6IEluaWNpYW5kbyBhdHVhbGl6YcOnw6NvIGRlIHNhbGRvczonLCB7IHNlbmRlcklkLCByZWNlaXZlcklkLCBhbW91bnQgfSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IGJhbGFuY2VzXG4gICAgICBjb25zdCBzZW5kZXJCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKHNlbmRlcklkKTtcbiAgICAgIGNvbnN0IHJlY2VpdmVyQmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZShyZWNlaXZlcklkKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEk6IFNhbGRvcyBhdHVhaXM6JywgeyBzZW5kZXJCYWxhbmNlLCByZWNlaXZlckJhbGFuY2UgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBzZW5kZXIncyBiYWxhbmNlIChzdWJ0cmFjdCBhbW91bnQpXG4gICAgICBjb25zdCBuZXdTZW5kZXJCYWxhbmNlID0gc2VuZGVyQmFsYW5jZSAtIGFtb3VudDtcbiAgICAgIGF3YWl0IHRoaXMuc2V0QmFsYW5jZSh7XG4gICAgICAgIHVzZXJfaWQ6IHNlbmRlcklkLFxuICAgICAgICBiYWxhbmNlOiBuZXdTZW5kZXJCYWxhbmNlXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIHJlY2VpdmVyJ3MgYmFsYW5jZSAoYWRkIGFtb3VudClcbiAgICAgIGF3YWl0IHRoaXMuc2V0QmFsYW5jZSh7XG4gICAgICAgIHVzZXJfaWQ6IHJlY2VpdmVySWQsXG4gICAgICAgIGJhbGFuY2U6IHJlY2VpdmVyQmFsYW5jZSArIGFtb3VudFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJldHVybiB1cGRhdGVkIGJhbGFuY2VzXG4gICAgICBjb25zdCB1cGRhdGVkU2VuZGVyQmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZShzZW5kZXJJZCk7XG4gICAgICBjb25zdCB1cGRhdGVkUmVjZWl2ZXJCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKHJlY2VpdmVySWQpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSTogU2FsZG9zIGF0dWFsaXphZG9zOicsIHsgdXBkYXRlZFNlbmRlckJhbGFuY2UsIHVwZGF0ZWRSZWNlaXZlckJhbGFuY2UgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbmRlckJhbGFuY2U6IHVwZGF0ZWRTZW5kZXJCYWxhbmNlLFxuICAgICAgICByZWNlaXZlckJhbGFuY2U6IHVwZGF0ZWRSZWNlaXZlckJhbGFuY2VcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogRXJybyBhbyBhdHVhbGl6YXIgc2FsZG9zOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICBhc3luYyB0cmFuc2Zlck1vbmV5KGRhdGE6IFRyYW5zZmVyUmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9wYXkvcG9zYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zZmVyIGZhaWxlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgdHJhbnNmZXJQaXgoZGF0YTogUGl4VHJhbnNmZXJSZXF1ZXN0KSB7XG4gICAgY29uc29sZS5sb2coJ0luaWNpYW5kbyB0cmFuc2ZlcsOqbmNpYSBQSVggY29tIGRhZG9zOicsIHtcbiAgICAgICAgZnJvbV91c2VyX2lkOiBkYXRhLmZyb21fdXNlcl9pZCxcbiAgICAgICAgdG9fdXNlcl9pZDogZGF0YS50b191c2VyX2lkLFxuICAgICAgICBhbW91bnQ6IGRhdGEuYW1vdW50XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgICAgZnJvbV91c2VyX2lkOiBOdW1iZXIoZGF0YS5mcm9tX3VzZXJfaWQpLFxuICAgICAgICB0b191c2VyX2lkOiBOdW1iZXIoZGF0YS50b191c2VyX2lkKSxcbiAgICAgICAgYW1vdW50OiBOdW1iZXIoZGF0YS5hbW91bnQpXG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IGJvZHkgZm9ybWF0YWRvOicsIHJlcXVlc3RCb2R5KTtcbiAgICBjb25zb2xlLmxvZygnVVJMIGRhIHJlcXVpc2nDp8OjbzonLCBgJHtBUElfQkFTRV9VUkx9L3BheS9waXhgKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9wYXkvcGl4YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIG5hIHRyYW5zZmVyw6puY2lhIFBJWDonLCB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICB1cmw6IHJlc3BvbnNlLnVybFxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQSVggdHJhbnNmZXIgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBwYXlMaW5rKGRhdGE6IGFueSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9wYXkvbGlua2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5rIHBheW1lbnQgZmFpbGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBjYXJkUGF5bWVudChkYXRhOiBhbnkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vY2FyZF9wYXltZW50YCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcmQgcGF5bWVudCBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9LFxuXG4gIGFzeW5jIGNyZWF0ZVJlY2VpdmFibGUoZGF0YTogYW55KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3JlY2VpdmFibGVzYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgcmVjZWl2YWJsZScpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0VXNlckluZm8oaWRlbnRpZmllcjogc3RyaW5nKTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICBjb25zb2xlLmxvZygnZ2V0VXNlckluZm8gY2hhbWFkbyBjb206JywgaWRlbnRpZmllcik7XG4gICAgY29uc3QgbG9jYWxVc2VyID0gdXNlckRiLmdldFVzZXJCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgaWYgKGxvY2FsVXNlcikge1xuICAgICAgY29uc29sZS5sb2coJ1VzdcOhcmlvIGVuY29udHJhZG8gbm8gYmFuY28gbG9jYWw6JywgbG9jYWxVc2VyKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEJ1c2NhIG9zIGRldGFsaGVzIGNvbXBsZXRvcyAoaW5jbHVpbmRvIHNhbGRvKSBkYSBBUEkgdXNhbmRvIG8gSURcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJzLyR7bG9jYWxVc2VyLmlkfWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGdldCB1c2VyIGRldGFpbHMgZnJvbSBBUEkgZm9yIElEICR7bG9jYWxVc2VyLmlkfSwgZmFsbGluZyBiYWNrIHRvIGRpcmVjdCBBUEkgc2VhcmNoYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBmZXRjaGluZyB1c2VyIGRldGFpbHMgZnJvbSBBUEksIGZhbGxpbmcgYmFjayB0byBkaXJlY3QgQVBJIHNlYXJjaDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2UgbsOjbyBlbmNvbnRyb3Ugbm8gYmFuY28gbG9jYWwgb3UgZmFsaG91IGFvIGJ1c2NhciBkZXRhbGhlcywgdGVudGEgYSBBUEkgZGlyZXRhbWVudGVcbiAgICAvLyBTZSBmb3IgdW0gbsO6bWVybywgdXNhIG8gZW5kcG9pbnQgL3VzZXJzL3tpZH1cbiAgICBpZiAoIWlzTmFOKE51bWJlcihpZGVudGlmaWVyKSkpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS91c2Vycy8ke2lkZW50aWZpZXJ9YCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1c2VyIGluZm8nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG5cbiAgICAvLyBTZSBuw6NvIGZvciBuw7ptZXJvLCBwcmltZWlybyBidXNjYSBvIElEIHVzYW5kbyAvdXNlcnMvc2VhcmNoXG4gICAgY29uc3Qgc2VhcmNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJzL3NlYXJjaD9xdWVyeT0ke2VuY29kZVVSSUNvbXBvbmVudChpZGVudGlmaWVyKX1gLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGlmICghc2VhcmNoUmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNlYXJjaCB1c2VyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VhcmNoRGF0YSA9IGF3YWl0IHNlYXJjaFJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zb2xlLmxvZygnUmVzcG9zdGEgZGEgYnVzY2EgZGUgdXN1w6FyaW86Jywgc2VhcmNoRGF0YSk7XG5cbiAgICBsZXQgdXNlcklkOiBudW1iZXI7XG4gICAgLy8gU2UgcmV0b3JuYXIgYXJyYXksIHBlZ2EgbyBwcmltZWlybyB1c3XDoXJpbyBjb20gaWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWFyY2hEYXRhKSAmJiBzZWFyY2hEYXRhLmxlbmd0aCA+IDAgJiYgc2VhcmNoRGF0YVswXS5pZCkge1xuICAgICAgdXNlcklkID0gc2VhcmNoRGF0YVswXS5pZDtcbiAgICB9XG4gICAgLy8gU2UgcmV0b3JuYXIgb2JqZXRvIMO6bmljb1xuICAgIGVsc2UgaWYgKHNlYXJjaERhdGEgJiYgc2VhcmNoRGF0YS5pZCkge1xuICAgICAgdXNlcklkID0gc2VhcmNoRGF0YS5pZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzdcOhcmlvIG7Do28gZW5jb250cmFkbycpO1xuICAgIH1cblxuICAgIC8vIEFnb3JhIGJ1c2NhIG9zIGRldGFsaGVzIGNvbXBsZXRvcyB1c2FuZG8gbyBJRFxuICAgIGNvbnN0IHVzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vdXNlcnMvJHt1c2VySWR9YCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBpZiAoIXVzZXJSZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHVzZXIgZGV0YWlscycpO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VyUmVzcG9uc2UuanNvbigpO1xuICB9LFxuXG4gIGFzeW5jIGNyZWF0ZVVzZXIoZGF0YTogeyBoYW5kbGU6IHN0cmluZyB9KTogUHJvbWlzZTxVc2VyUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9xZS1hcGkuc2VydmljZXMuc3RhZ2luZy5jbG91ZHdhbGsubmV0d29yay91c2Vycy9uZXcnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgLy8gU2UgbyBoYW5kbGUgasOhIGV4aXN0ZSwgdGVudGEgY3JpYXIgY29tIHVtIHN1Zml4byBhbGVhdMOzcmlvXG4gICAgICBpZiAocmVzLmVycm9yICYmIHJlcy5lcnJvci5pbmNsdWRlcygnaGFuZGxlIGhhcyBhbHJlYWR5IGJlZW4gdGFrZW4nKSkge1xuICAgICAgICBjb25zdCBuZXdIYW5kbGUgPSBgJHtkYXRhLmhhbmRsZX0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDApfWA7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVzZXIoeyBoYW5kbGU6IG5ld0hhbmRsZSB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIGNyaWFyIHVzdcOhcmlvOicsIHJlcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMubWVzc2FnZSB8fCAnRXJybyBhbyBjcmlhciB1c3XDoXJpbycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gZGUgcmVkZSBhbyBjcmlhciB1c3XDoXJpbzonLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufTsgIl0sIm5hbWVzIjpbInVzZXJEYiIsIkFQSV9CQVNFX1VSTCIsImFwaSIsImdldEJhbGFuY2UiLCJ1c2VySWQiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsImVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIkVycm9yIiwiZGF0YSIsImpzb24iLCJiYWxhbmNlIiwic2V0QmFsYW5jZSIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzdWx0IiwidXBkYXRlQmFsYW5jZXNBZnRlclRyYW5zYWN0aW9uIiwic2VuZGVySWQiLCJyZWNlaXZlcklkIiwiYW1vdW50Iiwic2VuZGVyQmFsYW5jZSIsInJlY2VpdmVyQmFsYW5jZSIsIm5ld1NlbmRlckJhbGFuY2UiLCJ1c2VyX2lkIiwidXBkYXRlZFNlbmRlckJhbGFuY2UiLCJ1cGRhdGVkUmVjZWl2ZXJCYWxhbmNlIiwidHJhbnNmZXJNb25leSIsInRyYW5zZmVyUGl4IiwiZnJvbV91c2VyX2lkIiwidG9fdXNlcl9pZCIsInJlcXVlc3RCb2R5IiwiTnVtYmVyIiwidXJsIiwicGF5TGluayIsImNhcmRQYXltZW50IiwiY3JlYXRlUmVjZWl2YWJsZSIsImdldFVzZXJJbmZvIiwiaWRlbnRpZmllciIsImxvY2FsVXNlciIsImdldFVzZXJCeUlkZW50aWZpZXIiLCJpZCIsIndhcm4iLCJpc05hTiIsInNlYXJjaFJlc3BvbnNlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VhcmNoRGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInVzZXJSZXNwb25zZSIsImNyZWF0ZVVzZXIiLCJyZXMiLCJpbmNsdWRlcyIsIm5ld0hhbmRsZSIsIk1hdGgiLCJoYW5kbGUiLCJmbG9vciIsInJhbmRvbSIsIm1lc3NhZ2UiLCJlcnIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api.ts\n"));

/***/ })

});