"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api)\n/* harmony export */ });\nconst API_BASE_URL = 'https://qe-api.services.staging.cloudwalk.network';\nconst api = {\n    async getBalance (userId) {\n        console.log('API: Buscando saldo para userId:', userId);\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(userId), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                console.error('API: Erro ao buscar saldo:', response.status, response.statusText);\n                throw new Error('Failed to fetch balance');\n            }\n            const data = await response.json();\n            console.log('API: Saldo obtido:', data);\n            return data.balance;\n        } catch (error) {\n            console.error('API: Erro na chamada getBalance:', error);\n            throw error;\n        }\n    },\n    async setBalance (data) {\n        console.log('API: Atualizando saldo:', data);\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/users/set-balance\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(data)\n            });\n            if (!response.ok) {\n                console.error('API: Erro ao atualizar saldo:', response.status, response.statusText);\n                throw new Error('Failed to set balance');\n            }\n            const result = await response.json();\n            console.log('API: Saldo atualizado com sucesso:', result);\n            return result;\n        } catch (error) {\n            console.error('API: Erro na chamada setBalance:', error);\n            throw error;\n        }\n    },\n    async updateBalancesAfterTransaction (senderId, receiverId, amount) {\n        console.log('API: Iniciando atualização de saldos:', {\n            senderId,\n            receiverId,\n            amount\n        });\n        try {\n            // Get current balances\n            const senderBalance = await this.getBalance(senderId);\n            const receiverBalance = await this.getBalance(receiverId);\n            console.log('API: Saldos atuais:', {\n                senderBalance,\n                receiverBalance\n            });\n            // Update sender's balance (subtract amount)\n            const newSenderBalance = senderBalance - amount;\n            await this.setBalance({\n                user_id: senderId,\n                balance: newSenderBalance\n            });\n            // Update receiver's balance (add amount)\n            await this.setBalance({\n                user_id: receiverId,\n                balance: receiverBalance + amount\n            });\n            // Return updated balances\n            const updatedSenderBalance = await this.getBalance(senderId);\n            const updatedReceiverBalance = await this.getBalance(receiverId);\n            console.log('API: Saldos atualizados:', {\n                updatedSenderBalance,\n                updatedReceiverBalance\n            });\n            return {\n                senderBalance: updatedSenderBalance,\n                receiverBalance: updatedReceiverBalance\n            };\n        } catch (error) {\n            console.error('API: Erro ao atualizar saldos:', error);\n            throw error;\n        }\n    },\n    async transferMoney (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/pos\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Transfer failed');\n        }\n        return response.json();\n    },\n    async transferPix (data) {\n        // Se from_user_id não foi fornecido, tenta pegar do localStorage\n        if (!data.from_user_id && \"object\" !== 'undefined') {\n            const storedId = localStorage.getItem('userId');\n            if (storedId) {\n                data.from_user_id = Number(storedId);\n            }\n        }\n        if (!data.from_user_id) {\n            throw new Error('from_user_id is required for PIX transfers');\n        }\n        console.log('Iniciando transferência PIX com dados:', {\n            from_user_id: data.from_user_id,\n            to_user_id: data.to_user_id,\n            amount: data.amount\n        });\n        const requestBody = {\n            from_user_id: Number(data.from_user_id),\n            to_user_id: Number(data.to_user_id),\n            amount: Number(data.amount)\n        };\n        console.log('Payload enviado para /pay/pix:', requestBody);\n        console.log('URL da requisição:', \"\".concat(API_BASE_URL, \"/pay/pix\"));\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/pix\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json',\n                    'Origin': window.location.origin\n                },\n                body: JSON.stringify(requestBody)\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Erro na transferência PIX:', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    error: errorText\n                });\n                throw new Error(\"PIX transfer failed: \".concat(errorText));\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Erro detalhado na transferência PIX:', error);\n            throw error;\n        }\n    },\n    async payLink (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/pay/link\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Link payment failed');\n        }\n        return response.json();\n    },\n    async cardPayment (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/card_payment\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Card payment failed');\n        }\n        return response.json();\n    },\n    async createReceivable (data) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/receivables\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error('Failed to create receivable');\n        }\n        return response.json();\n    },\n    async getUserInfo (identifier) {\n        // Se for número, busca direto pelo ID\n        if (/^\\d+$/.test(identifier)) {\n            const res = await fetch(\"\".concat(API_BASE_URL, \"/users/\").concat(identifier));\n            return res.json();\n        }\n        // Busca por handle, email, cpf, etc\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/users/search?query=\").concat(encodeURIComponent(identifier)));\n        const data = await res.json();\n        if (Array.isArray(data) && data.length > 0) return data[0];\n        if (data && data.id) return data;\n        throw new Error('Usuário não encontrado');\n    },\n    async createUser (data) {\n        const response = await fetch('https://qe-api.services.staging.cloudwalk.network/users/new', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(data)\n        });\n        const res = await response.json();\n        if (!response.ok) {\n            throw new Error(res.message || 'Erro ao criar usuário');\n        }\n        return res;\n    }\n};\nasync function resolveUserId(identifier) {\n    try {\n        const user = await api.getUserInfo(identifier);\n        if (user && typeof user.id === 'number' && user.id > 0) {\n            return user.id;\n        }\n        throw new Error('ID de usuário inválido');\n    } catch (err) {\n        console.error('Erro ao resolver ID do usuário:', err);\n        throw new Error('Não foi possível encontrar o usuário de destino.');\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNUO0FBQ0YsRUFBRTtBQUVGLGVBQWVRLGNBQWNWLFVBQWtCO0lBQzdDLElBQUk7UUFDRixNQUFNVyxPQUFPLE1BQU03RCxJQUFJaUQsV0FBVyxDQUFDQztRQUNuQyxJQUFJVyxRQUFRLE9BQU9BLEtBQUtKLEVBQUUsS0FBSyxZQUFZSSxLQUFLSixFQUFFLEdBQUcsR0FBRztZQUN0RCxPQUFPSSxLQUFLSixFQUFFO1FBQ2hCO1FBQ0EsTUFBTSxJQUFJNUMsTUFBTTtJQUNsQixFQUFFLE9BQU9pRCxLQUFLO1FBQ1ozRCxRQUFRTyxLQUFLLENBQUMsbUNBQW1Db0Q7UUFDakQsTUFBTSxJQUFJakQsTUFBTTtJQUNsQjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvY2xhcmFyaWJlaXJvL0dJVFMvUUUgLSBDaGFsbGVuZ2Uvc3JjL3NlcnZpY2VzL2FwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VyRGIgfSBmcm9tICcuL3VzZXJEYic7XG5cbmNvbnN0IEFQSV9CQVNFX1VSTCA9ICdodHRwczovL3FlLWFwaS5zZXJ2aWNlcy5zdGFnaW5nLmNsb3Vkd2Fsay5uZXR3b3JrJztcblxuaW50ZXJmYWNlIFRyYW5zZmVyUmVxdWVzdCB7XG4gIHRvX3VzZXJfaWQ6IG51bWJlcjtcbiAgYW1vdW50OiBudW1iZXI7XG4gIHBheW1lbnRfbWV0aG9kOiAnZGViaXQnIHwgJ2NyZWRpdCc7XG59XG5cbmludGVyZmFjZSBQaXhUcmFuc2ZlclJlcXVlc3Qge1xuICBmcm9tX3VzZXJfaWQ/OiBudW1iZXI7XG4gIHRvX3VzZXJfaWQ6IG51bWJlcjtcbiAgYW1vdW50OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBTZXRCYWxhbmNlUmVxdWVzdCB7XG4gIHVzZXJfaWQ6IG51bWJlcjtcbiAgYmFsYW5jZTogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVXNlclJlc3BvbnNlIHtcbiAgaWQ6IG51bWJlcjtcbiAgaGFuZGxlOiBzdHJpbmc7XG4gIGJhbGFuY2U6IG51bWJlcjtcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBhcGkgPSB7XG4gIGFzeW5jIGdldEJhbGFuY2UodXNlcklkOiBudW1iZXIpIHtcbiAgICBjb25zb2xlLmxvZygnQVBJOiBCdXNjYW5kbyBzYWxkbyBwYXJhIHVzZXJJZDonLCB1c2VySWQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vdXNlcnMvJHt1c2VySWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSTogRXJybyBhbyBidXNjYXIgc2FsZG86JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYmFsYW5jZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSTogU2FsZG8gb2J0aWRvOicsIGRhdGEpO1xuICAgICAgcmV0dXJuIGRhdGEuYmFsYW5jZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJOiBFcnJvIG5hIGNoYW1hZGEgZ2V0QmFsYW5jZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgYXN5bmMgc2V0QmFsYW5jZShkYXRhOiBTZXRCYWxhbmNlUmVxdWVzdCkge1xuICAgIGNvbnNvbGUubG9nKCdBUEk6IEF0dWFsaXphbmRvIHNhbGRvOicsIGRhdGEpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vdXNlcnMvc2V0LWJhbGFuY2VgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQVBJOiBFcnJvIGFvIGF0dWFsaXphciBzYWxkbzonLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzZXQgYmFsYW5jZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ0FQSTogU2FsZG8gYXR1YWxpemFkbyBjb20gc3VjZXNzbzonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQVBJOiBFcnJvIG5hIGNoYW1hZGEgc2V0QmFsYW5jZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgYXN5bmMgdXBkYXRlQmFsYW5jZXNBZnRlclRyYW5zYWN0aW9uKHNlbmRlcklkOiBudW1iZXIsIHJlY2VpdmVySWQ6IG51bWJlciwgYW1vdW50OiBudW1iZXIpIHtcbiAgICBjb25zb2xlLmxvZygnQVBJOiBJbmljaWFuZG8gYXR1YWxpemHDp8OjbyBkZSBzYWxkb3M6JywgeyBzZW5kZXJJZCwgcmVjZWl2ZXJJZCwgYW1vdW50IH0pO1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBiYWxhbmNlc1xuICAgICAgY29uc3Qgc2VuZGVyQmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZShzZW5kZXJJZCk7XG4gICAgICBjb25zdCByZWNlaXZlckJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UocmVjZWl2ZXJJZCk7XG4gICAgICBjb25zb2xlLmxvZygnQVBJOiBTYWxkb3MgYXR1YWlzOicsIHsgc2VuZGVyQmFsYW5jZSwgcmVjZWl2ZXJCYWxhbmNlIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgc2VuZGVyJ3MgYmFsYW5jZSAoc3VidHJhY3QgYW1vdW50KVxuICAgICAgY29uc3QgbmV3U2VuZGVyQmFsYW5jZSA9IHNlbmRlckJhbGFuY2UgLSBhbW91bnQ7XG4gICAgICBhd2FpdCB0aGlzLnNldEJhbGFuY2Uoe1xuICAgICAgICB1c2VyX2lkOiBzZW5kZXJJZCxcbiAgICAgICAgYmFsYW5jZTogbmV3U2VuZGVyQmFsYW5jZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSByZWNlaXZlcidzIGJhbGFuY2UgKGFkZCBhbW91bnQpXG4gICAgICBhd2FpdCB0aGlzLnNldEJhbGFuY2Uoe1xuICAgICAgICB1c2VyX2lkOiByZWNlaXZlcklkLFxuICAgICAgICBiYWxhbmNlOiByZWNlaXZlckJhbGFuY2UgKyBhbW91bnRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXR1cm4gdXBkYXRlZCBiYWxhbmNlc1xuICAgICAgY29uc3QgdXBkYXRlZFNlbmRlckJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2Uoc2VuZGVySWQpO1xuICAgICAgY29uc3QgdXBkYXRlZFJlY2VpdmVyQmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZShyZWNlaXZlcklkKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBUEk6IFNhbGRvcyBhdHVhbGl6YWRvczonLCB7IHVwZGF0ZWRTZW5kZXJCYWxhbmNlLCB1cGRhdGVkUmVjZWl2ZXJCYWxhbmNlIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZW5kZXJCYWxhbmNlOiB1cGRhdGVkU2VuZGVyQmFsYW5jZSxcbiAgICAgICAgcmVjZWl2ZXJCYWxhbmNlOiB1cGRhdGVkUmVjZWl2ZXJCYWxhbmNlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBUEk6IEVycm8gYW8gYXR1YWxpemFyIHNhbGRvczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgYXN5bmMgdHJhbnNmZXJNb25leShkYXRhOiBUcmFuc2ZlclJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vcGF5L3Bvc2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2ZlciBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9LFxuXG4gIGFzeW5jIHRyYW5zZmVyUGl4KGRhdGE6IFBpeFRyYW5zZmVyUmVxdWVzdCkge1xuICAgIC8vIFNlIGZyb21fdXNlcl9pZCBuw6NvIGZvaSBmb3JuZWNpZG8sIHRlbnRhIHBlZ2FyIGRvIGxvY2FsU3RvcmFnZVxuICAgIGlmICghZGF0YS5mcm9tX3VzZXJfaWQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHN0b3JlZElkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJJZCcpO1xuICAgICAgaWYgKHN0b3JlZElkKSB7XG4gICAgICAgIGRhdGEuZnJvbV91c2VyX2lkID0gTnVtYmVyKHN0b3JlZElkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRhdGEuZnJvbV91c2VyX2lkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21fdXNlcl9pZCBpcyByZXF1aXJlZCBmb3IgUElYIHRyYW5zZmVycycpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdJbmljaWFuZG8gdHJhbnNmZXLDqm5jaWEgUElYIGNvbSBkYWRvczonLCB7XG4gICAgICAgIGZyb21fdXNlcl9pZDogZGF0YS5mcm9tX3VzZXJfaWQsXG4gICAgICAgIHRvX3VzZXJfaWQ6IGRhdGEudG9fdXNlcl9pZCxcbiAgICAgICAgYW1vdW50OiBkYXRhLmFtb3VudFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgIGZyb21fdXNlcl9pZDogTnVtYmVyKGRhdGEuZnJvbV91c2VyX2lkKSxcbiAgICAgICAgdG9fdXNlcl9pZDogTnVtYmVyKGRhdGEudG9fdXNlcl9pZCksXG4gICAgICAgIGFtb3VudDogTnVtYmVyKGRhdGEuYW1vdW50KVxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygnUGF5bG9hZCBlbnZpYWRvIHBhcmEgL3BheS9waXg6JywgcmVxdWVzdEJvZHkpO1xuICAgIGNvbnNvbGUubG9nKCdVUkwgZGEgcmVxdWlzacOnw6NvOicsIGAke0FQSV9CQVNFX1VSTH0vcGF5L3BpeGApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3BheS9waXhgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ09yaWdpbic6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gbmEgdHJhbnNmZXLDqm5jaWEgUElYOicsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclRleHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQSVggdHJhbnNmZXIgZmFpbGVkOiAke2Vycm9yVGV4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBkZXRhbGhhZG8gbmEgdHJhbnNmZXLDqm5jaWEgUElYOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIHBheUxpbmsoZGF0YTogYW55KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3BheS9saW5rYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmsgcGF5bWVudCBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9LFxuXG4gIGFzeW5jIGNhcmRQYXltZW50KGRhdGE6IGFueSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9jYXJkX3BheW1lbnRgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FyZCBwYXltZW50IGZhaWxlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgY3JlYXRlUmVjZWl2YWJsZShkYXRhOiBhbnkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vcmVjZWl2YWJsZXNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSByZWNlaXZhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBnZXRVc2VySW5mbyhpZGVudGlmaWVyOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIC8vIFNlIGZvciBuw7ptZXJvLCBidXNjYSBkaXJldG8gcGVsbyBJRFxuICAgIGlmICgvXlxcZCskLy50ZXN0KGlkZW50aWZpZXIpKSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJzLyR7aWRlbnRpZmllcn1gKTtcbiAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgIH1cbiAgICAvLyBCdXNjYSBwb3IgaGFuZGxlLCBlbWFpbCwgY3BmLCBldGNcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L3VzZXJzL3NlYXJjaD9xdWVyeT0ke2VuY29kZVVSSUNvbXBvbmVudChpZGVudGlmaWVyKX1gKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA+IDApIHJldHVybiBkYXRhWzBdO1xuICAgIGlmIChkYXRhICYmIGRhdGEuaWQpIHJldHVybiBkYXRhO1xuICAgIHRocm93IG5ldyBFcnJvcignVXN1w6FyaW8gbsOjbyBlbmNvbnRyYWRvJyk7XG4gIH0sXG5cbiAgYXN5bmMgY3JlYXRlVXNlcihkYXRhOiB7IGhhbmRsZTogc3RyaW5nIH0pOiBQcm9taXNlPFVzZXJSZXNwb25zZT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vcWUtYXBpLnNlcnZpY2VzLnN0YWdpbmcuY2xvdWR3YWxrLm5ldHdvcmsvdXNlcnMvbmV3Jywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMubWVzc2FnZSB8fCAnRXJybyBhbyBjcmlhciB1c3XDoXJpbycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVXNlcklkKGlkZW50aWZpZXI6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IGFwaS5nZXRVc2VySW5mbyhpZGVudGlmaWVyKTtcbiAgICBpZiAodXNlciAmJiB0eXBlb2YgdXNlci5pZCA9PT0gJ251bWJlcicgJiYgdXNlci5pZCA+IDApIHtcbiAgICAgIHJldHVybiB1c2VyLmlkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lEIGRlIHVzdcOhcmlvIGludsOhbGlkbycpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvIGFvIHJlc29sdmVyIElEIGRvIHVzdcOhcmlvOicsIGVycik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOw6NvIGZvaSBwb3Nzw612ZWwgZW5jb250cmFyIG8gdXN1w6FyaW8gZGUgZGVzdGluby4nKTtcbiAgfVxufSAiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwiYXBpIiwiZ2V0QmFsYW5jZSIsInVzZXJJZCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIm9rIiwiZXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImJhbGFuY2UiLCJzZXRCYWxhbmNlIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN1bHQiLCJ1cGRhdGVCYWxhbmNlc0FmdGVyVHJhbnNhY3Rpb24iLCJzZW5kZXJJZCIsInJlY2VpdmVySWQiLCJhbW91bnQiLCJzZW5kZXJCYWxhbmNlIiwicmVjZWl2ZXJCYWxhbmNlIiwibmV3U2VuZGVyQmFsYW5jZSIsInVzZXJfaWQiLCJ1cGRhdGVkU2VuZGVyQmFsYW5jZSIsInVwZGF0ZWRSZWNlaXZlckJhbGFuY2UiLCJ0cmFuc2Zlck1vbmV5IiwidHJhbnNmZXJQaXgiLCJmcm9tX3VzZXJfaWQiLCJzdG9yZWRJZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJOdW1iZXIiLCJ0b191c2VyX2lkIiwicmVxdWVzdEJvZHkiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImVycm9yVGV4dCIsInRleHQiLCJwYXlMaW5rIiwiY2FyZFBheW1lbnQiLCJjcmVhdGVSZWNlaXZhYmxlIiwiZ2V0VXNlckluZm8iLCJpZGVudGlmaWVyIiwidGVzdCIsInJlcyIsImVuY29kZVVSSUNvbXBvbmVudCIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImlkIiwiY3JlYXRlVXNlciIsIm1lc3NhZ2UiLCJyZXNvbHZlVXNlcklkIiwidXNlciIsImVyciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api.ts\n"));

/***/ })

});